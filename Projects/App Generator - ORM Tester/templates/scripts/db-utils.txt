/**
 * Database utilities for ORM testing
 * Provides: schema export, table cleanup, result file writing
 */

import postgres from 'postgres';
import * as fs from 'node:fs';
import * as path from 'node:path';

const DB_HOST = process.env.DB_HOST ?? 'localhost';
const DB_PORT = Number(process.env.DB_PORT ?? 5432);
const DB_USER = process.env.DB_USERNAME ?? 'postgres';
const DB_PASSWORD = process.env.DB_PASSWORD ?? 'postgres';
const DB_NAME = process.env.DB_NAME ?? 'orm_tester';

export interface ColumnInfo {
  column_name: string;
  data_type: string;
  is_nullable: string;
  column_default: string | null;
  character_maximum_length: number | null;
}

export interface TableSchema {
  tableName: string;
  columns: ColumnInfo[];
}

export interface SchemaResult {
  orm: string;
  timestamp: string;
  database: string;
  tables: TableSchema[];
}

/**
 * Get a postgres connection
 */
export function getConnection(database?: string) {
  return postgres({
    host: DB_HOST,
    port: DB_PORT,
    user: DB_USER,
    password: DB_PASSWORD,
    database: database ?? DB_NAME,
  });
}

/**
 * Drop all tables in the public schema
 */
export async function cleanDatabase(): Promise<void> {
  const sql = getConnection();

  try {
    // Get all tables
    const tables = await sql`
      SELECT tablename FROM pg_tables
      WHERE schemaname = 'public'
    `;

    if (tables.length > 0) {
      // Drop all tables with CASCADE
      for (const table of tables) {
        await sql.unsafe(`DROP TABLE IF EXISTS "${table.tablename}" CASCADE`);
      }
      console.log(`  Dropped ${tables.length} tables`);
    }
  } finally {
    await sql.end();
  }
}

/**
 * Export database schema to structured format
 */
export async function exportSchema(ormName: string): Promise<SchemaResult> {
  const sql = getConnection();

  try {
    // Get all tables
    const tables = await sql`
      SELECT table_name
      FROM information_schema.tables
      WHERE table_schema = 'public'
      AND table_type = 'BASE TABLE'
      ORDER BY table_name
    `;

    const tableSchemas: TableSchema[] = [];

    for (const table of tables) {
      const tableName = String(table.table_name);

      // Get column definitions
      const columns = await sql`
        SELECT
          column_name,
          data_type,
          is_nullable,
          column_default,
          character_maximum_length
        FROM information_schema.columns
        WHERE table_schema = 'public'
        AND table_name = ${tableName}
        ORDER BY ordinal_position
      `;

      tableSchemas.push({
        tableName,
        columns: columns.map((col) => ({
          column_name: String(col.column_name),
          data_type: String(col.data_type),
          is_nullable: String(col.is_nullable),
          column_default: col.column_default ? String(col.column_default) : null,
          character_maximum_length: col.character_maximum_length ? Number(col.character_maximum_length) : null,
        })),
      });
    }

    return {
      orm: ormName,
      timestamp: new Date().toISOString(),
      database: DB_NAME,
      tables: tableSchemas,
    };
  } finally {
    await sql.end();
  }
}

/**
 * Write schema result to results directory
 */
export function writeResult(result: SchemaResult): void {
  const resultsDir = path.join(process.cwd(), 'results');

  if (!fs.existsSync(resultsDir)) {
    fs.mkdirSync(resultsDir, { recursive: true });
  }

  const filePath = path.join(resultsDir, `${result.orm}_result.json`);
  fs.writeFileSync(filePath, JSON.stringify(result, null, 2));
  console.log(`  Result written to: ${filePath}`);
}

/**
 * Create the test database if it doesn't exist
 */
export async function createDatabase(): Promise<void> {
  const sql = postgres({
    host: DB_HOST,
    port: DB_PORT,
    user: DB_USER,
    password: DB_PASSWORD,
    database: 'postgres',
  });

  try {
    // Check if database exists
    const result = await sql`
      SELECT 1 FROM pg_database WHERE datname = ${DB_NAME}
    `;

    if (result.length === 0) {
      await sql.unsafe(`CREATE DATABASE ${DB_NAME}`);
      console.log(`Database '${DB_NAME}' created`);
    } else {
      console.log(`Database '${DB_NAME}' already exists`);
    }
  } finally {
    await sql.end();
  }
}

/**
 * Drop the test database
 */
export async function dropDatabase(): Promise<void> {
  const sql = postgres({
    host: DB_HOST,
    port: DB_PORT,
    user: DB_USER,
    password: DB_PASSWORD,
    database: 'postgres',
  });

  try {
    // Terminate connections
    await sql`
      SELECT pg_terminate_backend(pg_stat_activity.pid)
      FROM pg_stat_activity
      WHERE pg_stat_activity.datname = ${DB_NAME}
      AND pid <> pg_backend_pid()
    `;

    await sql.unsafe(`DROP DATABASE IF EXISTS ${DB_NAME}`);
    console.log(`Database '${DB_NAME}' dropped`);
  } finally {
    await sql.end();
  }
}

// CLI support
const command = process.argv[2];
if (command === 'create') {
  await createDatabase();
} else if (command === 'drop') {
  await dropDatabase();
}
